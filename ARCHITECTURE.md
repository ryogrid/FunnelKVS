# Rustの手習い用に開発する分散KVS の設計メモ

- RedisやMemcachedのようなオンメモリでデータを保持するデータストアを実現する
- データの他ノードによる中継などによってNAT越え（要は複数の異なるネットワークにノードが存在する場合）することまで考えると、実装がかなり複雑になることが予想されるため、今回は単一ネットワーク内に全ノードがいて、それらのノード間で直接通信が可能であることを前提とする
- 各ノードは構成されたKVSへアクセスするための put, get, delete をREST API として提供する
  - 今回はパフォーマンスに重きを置かないこともあり、ストアできるデータはJSON形式として解釈可能なものに限定する（Valueの部分）
  - Keyの部分はそれほど大きくなることを想定せず、API呼び出し時のURLの部分に含める
  - KVSへのアクセスとは別に、DHTを構成するための通信も、（ひとまずは）REST APIとして定義し、ノード間のやり取りはそれを用いて行うものとする（いちいちソケットプログラミングするのは面倒なので・・）。コネクションを継続的に張り続けておかないと実装が複雑化するといったことが判明した場合は、見直しを行う
- 分散ハッシュテーブル（Distributed Hash Table, DHT）の技術を用いて、中央サーバ無しで動作するものとする
  - DHTのアルゴリズムとしては一番ポピュラーな "Chord" というアルゴリズムを採用する
  - 参考にする資料・ウェブサイト
    - [分散システムにおけるScalableな名前付けアルゴリズム「Chord Protocol」を実装してみた - Qiita](https://qiita.com/taisho6339/items/7f849b65e2deab6759a1)
    - [ChordアルゴリズムによるDHT入門 - slideshare](https://www.slideshare.net/did2/chorddht)
  - （おそらく）元々のChordアルゴリズムと異なる設計となるところ
    - put は複数ノードがデータを中継するが、最終的に到達した、データをストアするノードは、putを発行したノードに直接、put を行った旨を通知する（操作の成否の判断のため）
    - get は最終的に到達した、データを保持していたノードから get を発行したノードに直接データを返す
    - delete は最終的に到達した、データを保持していたノードから delete を発行したノードに直接、delete処理を行った旨を通知する（操作の成否の判断のため）
    - 以上は、目的のノードに到達した後に、行きでたどったルートを逆方向に戻る処理がレイテンシの増加につながるため、それをショートカットするための工夫（?）
      - put と get でデータの中継が行われるか否かという点が非対称になるのは少し気持ちが悪いがしょうがないということにする
      - 今回は全ノードが同一ネットワークに存在し、相互に通信可能という前提を置いているためこのような変更を加えるが、そのような前提が無く、NAT内に存在し、中継をしてもらわねば通信ができないようなノードを含む広域分散なネットワークを構築する場合は、このような方法はとれないはず
      - 広域分散のネットワークを構築する場合は、ルーティングや経路表の作成にあたって、NAT内に存在するノードへ対応するための考慮を加えなければならないと思われるが、それに加えて、UPnPを用いて、各ノードのデーモンがNATに穴を空けてグローバルIPでアクセス可能となるように振舞うことで、ネットワーク全体でグローバルIPでアクセス可能なノードの割合を増やさないと成立しないであろうと思われる
- ストアしたデータはオンメモリで保持するものとし、ストレージへの永続化はひとまず考えない
- ストレージへの永続化はしないが、DHTのアドレス空間上での隣接ノード等を相手方としたデータのレプリケーションは実装する。これにより、全ノードないし
多数のノードを一斉に落とすといったことをしなければ、データは失われないようになる（はず）
- 実装にはRust言語を用い、REST API実装のフレームワークや、極めて一般的な処理を担うライブラリを除き、フルスクラッチで実装する
- Chordアルゴリズムの理解とそれに基づく設計の検証のため、簡易的な、Chordアルゴリズムのシミュレータを Python（今のところの第一候補）を用いて作成する予定
  - 実システムを今回初めてまともに利用するRust言語で書いている中で、Chordアルゴリズムの実装方法の誤りによる想定しない動作が発生した場合、デバッグのコストが非常に大きくなることが予想されるため
